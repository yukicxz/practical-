#define _CRT_SECURE_NO_WARNINGS
#include "all.h"
void mergeSort(int* a, int l, int r);
int size = 0; // инициализируем размер массива нулем
int sizee() {
    char vibor = ' ';
    system("cls");
    printf("\033[93m""Текущая размерность массива: %d""\033[m", size);
    printf("\033[33m""\nХотите поменять? (Y/N): ""\033[m");
    getchar();
    scanf("%c", &vibor);
    vibor = toupper(vibor);
    if (vibor == 'Y')
    {
        printf("Введите размер массива больше одного: ");
        scanf("%d", &size);
        printf("Размер массива успешно введен\n");
        return show_menu();
    }
    else if (vibor == 'N')
    {
        system("cls");
        return show_menu();
    }
}

void mergeSortFunction(int size) {
    setlocale(LC_ALL, "Russian");
    int* a = (int*)malloc(size * sizeof(int));//выделение памяти под динамический массив
    FILE* nesort;
    FILE* sort;
    if (a == NULL) {//вывод ошибки в случае, если память не была выделена
        printf("Ошибка выделения памяти");
        return;
    }
    nesort = fopen("nesort.txt", "w");//открываем файл для несортированного массива
    // Заполняем элементы массива случайными числами и записываем в файл
    for (int i = 0; i < size; i++) {
        a[i] = rand() % 10000;
        fprintf(nesort, " %d", a[i]);
    }
    fclose(nesort);//закрываем файл
    time_t start = clock();//время до сортировки
    mergeSort(a, 0, size - 1);// вызываем функцию сортировки
    time_t stop = clock();//время после сортировки
    double time = (stop - start) / 1000.0;//время сортировки
    sort = fopen("sort.txt", "w");//открываем файл для сортированного массива
    // Записываем отсортированный массив в файл
    for (int i = 0; i < size; i++)
        fprintf( sort, " %d", a[i]);
    free(a);
    fclose(sort);//закрываем файл
    printf("Массив успешно отсортирован\nВремя сортировки:%5.3lf секунд", time);
    show_menu();
}
void mergeSort(int* a, int l, int r) {
    if (l >= r)//проверяем условие равенства левой и правой границы последовательности
        return;//управление возвращается вызывающей функции
    int mid = l + (r - l) / 2;// определяем середину массива
    //рекурсивно вызываем функцию сортировки для каждой половины
    mergeSort(a, l, mid);//вызов функции сортировки для первой половины последовательности
    mergeSort(a, mid + 1, r);//вызов функции сортировки для левой половины последовательности
    int i = l;// начало первой половины
    int j = mid + 1; // начало второй половины
    int* tmp = (int*)malloc((r - l + 1) * sizeof(int));// выделение памяти под дополнительный массив, в котором формируется
    //отсортированная последовательность
    if (tmp == NULL) {//вывод ошибки в случае, если память не была выделена
        printf("Ошибка выделения памяти");
        return;
    }

    for (int s = 0; s < r - l + 1; s++)//сортировка последоваельности
    {
        // записываем в формируемую последовательность меньший из элементов двух путей
        // или остаток первого пути если j > r
        if ((j > r) || ((i <= mid) && (a[i] < a[j]))) //проверка условия выхода за правую границу второй последовательности
            //или являеся ли элемент первой половины последовательности меньшим
        {
            tmp[s] = a[i];//записываем в дополнительный массив элемент первой половины последовательности
            i++;//инкрементируем i и продвигаемся по первой половине последовательности
        }
        else//если условие не выполняется
        {
            tmp[s] = a[j];//записываем в формируемую последовательность элемент второй половины последовательности
            j++;// инкрементируем j и продвигаемся по второй половине последовательности
        }
    }
    // переписываем сформированную последовательность в исходный массив
    for (int s = 0; s < r - l + 1; s++)
        a[l + s] = tmp[s];

    free(tmp);
}
void centerprintf(const char* str) { //функция определения центра консоли
    int width = 120; //высота
    int len = strlen(str); //длинна
    int startPos = (width - len) / 2; //определение центра
    for (int i = 0; i < startPos; i++) { //смещение до центра
        putchar(' ');
    }
    printf("%s", str);
}
int show_menu() { //объявление меню
    setlocale(LC_ALL, "Rus"); // установка русского языка
    char* frm = "%s"; //символьный формат для ассемблерной вставки
    char* text = ("\033[31m""Данного варианта нет. Выберите из предложенных.\n""\033[m"); //текст ассемблерной вставки
    printf("\n");
    centerprintf("=============================\n");
    centerprintf("        =""\033[91m""    Сортировка""\033[m"" Слиянием    =\n");
    centerprintf("=============================\n");
    centerprintf("|                           |\n");
    centerprintf("|     1. Сортировка         |\n");
    centerprintf("|                           |\n");
    centerprintf("         |""\033[91m""     2. Размер Массива     ""\033[m""|\n");
    centerprintf("|                           |\n");
    centerprintf("        |""\033[31m""     3. Выход              ""\033[m""|\n");
    centerprintf("|                           |\n");
    centerprintf("=============================\n");


    char choice; //переменная для выбора

    printf("Ваш выбор: ");
    scanf(" %c", &choice);
    printf("\n");

    switch (choice) { //переключатель для выбора пользователя
    case '1': //если пользователь ввел 1
        system("cls"); //очистка конслоли
        if (size <= 0) {
            printf("Размер массива не был введен\n");
            return show_menu();
        }
        else {
            mergeSortFunction(size);
            return show_menu();
        }
        break;
    case '2': //если пользователь ввел 2
        system("cls"); //очистка конслоли
        sizee();
        break;
    case '3': //если пользователь ввел 3
        exit(0);
        break;

    default: //если не выбран ни один из предложенных вариантов
        system("cls"); //очистка конслоли
        __asm { //начало ассемблерной вставки
            push text //заносим в стек указатель на переменную текст
            push frm //заносим в стек указатель на формат
            call printf //вызов функции printf
            add esp, 8 //восстановление стека
        }
        return show_menu(); //возврат в меню
    }
}


